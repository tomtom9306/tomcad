# Three.js Integration

## Overview

TomCAD's 3D visualization is built on **Three.js r178**, providing WebGL-based rendering with professional CAD-grade visual quality. The integration emphasizes **performance**, **accuracy**, and **maintainability** while supporting real-time interaction and complex structural geometry.

## Core Three.js Architecture

### ThreeJSSetup - Scene Initialization

```javascript
class ThreeJSSetup {
    constructor(container) {
        this.container = container;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        
        this.initialize();
    }
    
    initialize() {
        this.createScene();
        this.createCamera();
        this.createRenderer();
        this.createLights();
        this.createControls();
        this.setupEventListeners();
        this.startRenderLoop();
    }
    
    createScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xf0f0f0); // Light gray background
        
        // Create layers for organization
        this.scene.userData = {
            layers: {
                elements: 0,     // Structural elements
                grids: 1,        // Construction grids
                helpers: 2,      // Visual helpers
                ui: 3,          // UI overlays
                preview: 4       // Creation preview
            }
        };
        
        // Add coordinate system helper
        const axesHelper = new THREE.AxesHelper(1000);
        axesHelper.layers.set(this.scene.userData.layers.helpers);
        this.scene.add(axesHelper);
    }
    
    createCamera() {
        const aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera = new THREE.PerspectiveCamera(60, aspect, 10, 100000);
        
        // Set initial camera position (isometric-like view)
        this.camera.position.set(5000, 5000, 5000);
        this.camera.lookAt(0, 0, 0);
        
        // Add camera to scene for helper visibility
        this.scene.add(this.camera);
    }
    
    createRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
            powerPreference: "high-performance"
        });
        
        this.renderer.setSize(
            this.container.clientWidth, 
            this.container.clientHeight
        );
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Enable shadows for better visual quality
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Better color rendering
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        
        // Append to container
        this.container.appendChild(this.renderer.domElement);
    }
    
    createLights() {
        // Ambient light for general illumination
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambientLight);
        
        // Main directional light (sun-like)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10000, 10000, 5000);
        directionalLight.castShadow = true;
        
        // Configure shadow map
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 1000;
        directionalLight.shadow.camera.far = 50000;
        directionalLight.shadow.camera.left = -10000;
        directionalLight.shadow.camera.right = 10000;
        directionalLight.shadow.camera.top = 10000;
        directionalLight.shadow.camera.bottom = -10000;
        
        this.scene.add(directionalLight);
        
        // Fill light from opposite direction
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-5000, -5000, 5000);
        this.scene.add(fillLight);
    }
    
    createControls() {
        // Using OrbitControls for camera manipulation
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        
        // Configure controls for CAD-like behavior
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.screenSpacePanning = false;
        this.controls.minDistance = 100;
        this.controls.maxDistance = 50000;
        this.controls.maxPolarAngle = Math.PI; // Allow viewing from below
        
        // Set target to scene center
        this.controls.target.set(0, 0, 1500); // Slightly above ground plane
    }
    
    setupEventListeners() {
        // Handle window resize
        window.addEventListener('resize', this.onWindowResize.bind(this));
        
        // Handle visibility change (pause rendering when hidden)
        document.addEventListener('visibilitychange', this.onVisibilityChange.bind(this));
    }
    
    startRenderLoop() {
        const animate = () => {
            requestAnimationFrame(animate);
            
            if (document.hidden) return; // Don't render when tab is hidden
            
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
            
            // Publish render statistics
            EventBus.publish('render:frame', {
                frameTime: performance.now(),
                triangles: this.renderer.info.render.triangles,
                drawCalls: this.renderer.info.render.calls
            });
        };
        
        animate();
    }
    
    onWindowResize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }
    
    onVisibilityChange() {
        if (document.hidden) {
            // Pause rendering optimizations when tab is hidden
            this.renderer.setAnimationLoop(null);
        } else {
            this.startRenderLoop();
        }
    }
    
    // Cleanup
    dispose() {
        this.renderer.dispose();
        this.controls.dispose();
        window.removeEventListener('resize', this.onWindowResize);
        document.removeEventListener('visibilitychange', this.onVisibilityChange);
    }
}
```

## Mesh Generation Architecture

### MeshBuilder - Element to Three.js Conversion

```javascript
class MeshBuilder {
    static materialLibrary = new Map();
    static geometryCache = new Map();
    
    /**
     * Create Three.js mesh from element data
     * @param {Object} elementData - Element data from struktura.js
     * @returns {THREE.Mesh} Three.js mesh object
     */
    static createElement(elementData) {
        switch (elementData.type) {
            case 'beam':
                return this.createBeam(elementData);
            case 'column':
                return this.createColumn(elementData);
            case 'plate':
                return this.createPlate(elementData);
            case 'stairs':
                return this.createStairs(elementData);
            default:
                console.warn(`Unknown element type: ${elementData.type}`);
                return this.createFallbackMesh(elementData);
        }
    }
    
    /**
     * Create beam mesh
     * @param {Object} beamData - Beam element data
     * @returns {THREE.Mesh} Beam mesh
     */
    static createBeam(beamData) {
        // Get profile geometry
        const profile = ProfileManager.getProfile(beamData.profile);
        if (!profile) {
            throw new Error(`Profile not found: ${beamData.profile}`);
        }
        
        // Calculate beam properties
        const startPoint = new THREE.Vector3(...beamData.startPoint);
        const endPoint = new THREE.Vector3(...beamData.endPoint);
        const length = startPoint.distanceTo(endPoint);
        const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
        
        // Create extruded geometry
        const geometry = this.createExtrudedProfile(profile, length);
        
        // Apply operations (holes, cuts, etc.)
        if (beamData.operations && beamData.operations.length > 0) {
            geometry = this.applyOperations(geometry, beamData.operations);
        }
        
        // Create material
        const material = this.getMaterial(beamData.material || 'S355JR', 'element');
        
        // Create mesh
        const mesh = new THREE.Mesh(geometry, material);
        
        // Position and orient mesh
        this.positionBeam(mesh, startPoint, endPoint, beamData.rotation || 0);
        
        // Add metadata
        mesh.userData = {
            elementId: beamData.id,
            elementType: 'beam',
            elementData: beamData,
            profile: profile,
            length: length
        };
        
        // Enable shadows
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        return mesh;
    }
    
    /**
     * Create extruded profile geometry
     * @param {Object} profile - Steel profile data
     * @param {number} length - Extrusion length
     * @returns {THREE.ExtrudeGeometry} Extruded geometry
     */
    static createExtrudedProfile(profile, length) {
        // Check cache first
        const cacheKey = `${profile.name}_${length}`;
        if (this.geometryCache.has(cacheKey)) {
            return this.geometryCache.get(cacheKey).clone();
        }
        
        // Create profile shape
        const shape = this.createProfileShape(profile);
        
        // Extrude settings
        const extrudeSettings = {
            depth: length,
            bevelEnabled: false,
            steps: 1
        };
        
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        
        // Rotate to align with beam direction (Three.js extrudes along Z)
        geometry.rotateY(Math.PI / 2);
        geometry.translate(0, 0, -length / 2);
        
        // Cache geometry
        this.geometryCache.set(cacheKey, geometry.clone());
        
        return geometry;
    }
    
    /**
     * Create 2D profile shape from profile data
     * @param {Object} profile - Steel profile data
     * @returns {THREE.Shape} Profile shape
     */
    static createProfileShape(profile) {
        const shape = new THREE.Shape();
        
        switch (profile.type) {
            case 'IPE':
            case 'HEA':
            case 'HEB':
                return this.createIProfileShape(profile);
            case 'RHS':
                return this.createRHSProfileShape(profile);
            case 'CHS':
                return this.createCHSProfileShape(profile);
            case 'L':
                return this.createAngleProfileShape(profile);
            default:
                console.warn(`Unknown profile type: ${profile.type}`);
                return this.createFallbackShape(profile);
        }
    }
    
    /**
     * Create I-beam profile shape (IPE, HEA, HEB)
     * @param {Object} profile - I-beam profile data
     * @returns {THREE.Shape} I-beam shape
     */
    static createIProfileShape(profile) {
        const shape = new THREE.Shape();
        const { h, b, tw, tf, r } = profile.dimensions;
        
        const halfHeight = h / 2;
        const halfWidth = b / 2;
        const webHalfThickness = tw / 2;
        
        // Start from bottom-left
        shape.moveTo(-halfWidth, -halfHeight);
        
        // Bottom flange
        shape.lineTo(halfWidth, -halfHeight);
        shape.lineTo(halfWidth, -halfHeight + tf);
        
        // Right side of web with fillet
        shape.lineTo(webHalfThickness + r, -halfHeight + tf);
        
        if (r > 0) {
            // Fillet curve
            shape.quadraticCurveTo(
                webHalfThickness, -halfHeight + tf,
                webHalfThickness, -halfHeight + tf + r
            );
        }
        
        // Web right side
        shape.lineTo(webHalfThickness, halfHeight - tf - r);
        
        if (r > 0) {
            // Top fillet
            shape.quadraticCurveTo(
                webHalfThickness, halfHeight - tf,
                webHalfThickness + r, halfHeight - tf
            );
        }
        
        // Top flange
        shape.lineTo(halfWidth, halfHeight - tf);
        shape.lineTo(halfWidth, halfHeight);
        shape.lineTo(-halfWidth, halfHeight);
        shape.lineTo(-halfWidth, halfHeight - tf);
        
        // Left side (mirror of right side)
        shape.lineTo(-webHalfThickness - r, halfHeight - tf);
        
        if (r > 0) {
            shape.quadraticCurveTo(
                -webHalfThickness, halfHeight - tf,
                -webHalfThickness, halfHeight - tf - r
            );
        }
        
        shape.lineTo(-webHalfThickness, -halfHeight + tf + r);
        
        if (r > 0) {
            shape.quadraticCurveTo(
                -webHalfThickness, -halfHeight + tf,
                -webHalfThickness - r, -halfHeight + tf
            );
        }
        
        shape.lineTo(-halfWidth, -halfHeight + tf);
        shape.closePath();
        
        return shape;
    }
    
    /**
     * Position beam mesh in 3D space
     * @param {THREE.Mesh} mesh - Beam mesh
     * @param {THREE.Vector3} startPoint - Start position
     * @param {THREE.Vector3} endPoint - End position
     * @param {number} rotation - Rotation around beam axis (degrees)
     */
    static positionBeam(mesh, startPoint, endPoint, rotation = 0) {
        // Calculate center position
        const center = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
        mesh.position.copy(center);
        
        // Calculate direction and create rotation matrix
        const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
        const up = new THREE.Vector3(0, 0, 1);
        
        // Handle vertical beams
        if (Math.abs(direction.dot(up)) > 0.99) {
            up.set(0, 1, 0);
        }
        
        // Create rotation matrix to align beam with direction
        const matrix = new THREE.Matrix4().lookAt(
            new THREE.Vector3(0, 0, 0),
            direction,
            up
        );
        
        mesh.setRotationFromMatrix(matrix);
        
        // Apply additional rotation around beam axis
        if (rotation !== 0) {
            mesh.rotateX(rotation * Math.PI / 180);
        }
    }
    
    /**
     * Get or create material
     * @param {string} materialName - Material identifier
     * @param {string} type - Material type (element, preview, selected, etc.)
     * @returns {THREE.Material} Three.js material
     */
    static getMaterial(materialName, type = 'element') {
        const cacheKey = `${materialName}_${type}`;
        
        if (this.materialLibrary.has(cacheKey)) {
            return this.materialLibrary.get(cacheKey);
        }
        
        let material;
        
        switch (type) {
            case 'element':
                material = this.createElementMaterial(materialName);
                break;
            case 'preview':
                material = this.createPreviewMaterial();
                break;
            case 'selected':
                material = this.createSelectedMaterial();
                break;
            case 'highlighted':
                material = this.createHighlightedMaterial();
                break;
            default:
                material = this.createDefaultMaterial();
        }
        
        this.materialLibrary.set(cacheKey, material);
        return material;
    }
    
    /**
     * Create element material based on steel grade
     * @param {string} materialName - Steel grade (S355JR, S275, etc.)
     * @returns {THREE.MeshLambertMaterial} Element material
     */
    static createElementMaterial(materialName) {
        // Material color mapping
        const materialColors = {
            'S235JR': 0x888888,
            'S275JR': 0x999999,
            'S355JR': 0xaaaaaa,
            'S460JR': 0xbbbbbb
        };
        
        const color = materialColors[materialName] || 0x888888;
        
        return new THREE.MeshLambertMaterial({
            color: color,
            transparent: false,
            opacity: 1.0
        });
    }
    
    static createPreviewMaterial() {
        return new THREE.MeshLambertMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.6
        });
    }
    
    static createSelectedMaterial() {
        return new THREE.MeshLambertMaterial({
            color: 0xff6600,
            transparent: false,
            opacity: 1.0
        });
    }
    
    /**
     * Apply operations (holes, cuts) to geometry
     * @param {THREE.BufferGeometry} geometry - Base geometry
     * @param {Array} operations - Array of operation IDs
     * @returns {THREE.BufferGeometry} Modified geometry
     */
    static applyOperations(geometry, operations) {
        let resultGeometry = geometry;
        
        operations.forEach(operationId => {
            const operation = strukturaData.operations.find(op => op.id === operationId);
            if (operation) {
                resultGeometry = this.applyOperation(resultGeometry, operation);
            }
        });
        
        return resultGeometry;
    }
    
    /**
     * Apply single operation to geometry
     * @param {THREE.BufferGeometry} geometry - Base geometry
     * @param {Object} operation - Operation data
     * @returns {THREE.BufferGeometry} Modified geometry
     */
    static applyOperation(geometry, operation) {
        switch (operation.type) {
            case 'hole':
                return this.applyHoleOperation(geometry, operation);
            case 'slot':
                return this.applySlotOperation(geometry, operation);
            case 'cut':
                return this.applyCutOperation(geometry, operation);
            default:
                console.warn(`Unknown operation type: ${operation.type}`);
                return geometry;
        }
    }
    
    /**
     * Apply hole operation using CSG
     * @param {THREE.BufferGeometry} geometry - Base geometry
     * @param {Object} holeData - Hole operation data
     * @returns {THREE.BufferGeometry} Geometry with hole
     */
    static applyHoleOperation(geometry, holeData) {
        // Create hole geometry
        const holeGeometry = new THREE.CylinderGeometry(
            holeData.diameter / 2,
            holeData.diameter / 2,
            1000, // Make it longer than any beam thickness
            16
        );
        
        // Position hole
        holeGeometry.translate(
            holeData.position[0],
            holeData.position[1],
            holeData.position[2]
        );
        
        // Perform CSG subtraction
        // Note: This would require a CSG library like three-csg-ts
        return this.performCSGSubtraction(geometry, holeGeometry);
    }
    
    /**
     * CSG subtraction placeholder
     * @param {THREE.BufferGeometry} geometryA - Base geometry
     * @param {THREE.BufferGeometry} geometryB - Geometry to subtract
     * @returns {THREE.BufferGeometry} Result geometry
     */
    static performCSGSubtraction(geometryA, geometryB) {
        // TODO: Implement CSG operations using three-csg-ts or similar
        // For now, return original geometry
        console.warn('CSG operations not yet implemented');
        return geometryA;
    }
    
    /**
     * Cleanup unused geometries and materials
     */
    static cleanup() {
        // Dispose cached geometries
        this.geometryCache.forEach(geometry => geometry.dispose());
        this.geometryCache.clear();
        
        // Dispose cached materials
        this.materialLibrary.forEach(material => material.dispose());
        this.materialLibrary.clear();
    }
}
```

## Scene Management

### Object Lifecycle Management

```javascript
class SceneManager {
    constructor(scene) {
        this.scene = scene;
        this.elementObjects = new Map(); // elementId -> THREE.Object3D
        this.gridObjects = new Map();    // gridId -> THREE.Object3D
        this.previewObjects = new Map(); // type -> THREE.Object3D
    }
    
    /**
     * Add element to scene
     * @param {Object} elementData - Element data
     */
    addElement(elementData) {
        // Remove existing object if present
        this.removeElement(elementData.id);
        
        // Create new mesh
        const mesh = MeshBuilder.createElement(elementData);
        
        // Add to scene
        this.scene.add(mesh);
        this.elementObjects.set(elementData.id, mesh);
        
        EventBus.publish('scene:element:added', {
            elementId: elementData.id,
            mesh: mesh
        });
        
        return mesh;
    }
    
    /**
     * Update element in scene
     * @param {Object} elementData - Updated element data
     */
    updateElement(elementData) {
        const existingMesh = this.elementObjects.get(elementData.id);
        
        if (existingMesh) {
            // Store selection state
            const wasSelected = existingMesh.userData.selected;
            
            // Remove old mesh
            this.removeElement(elementData.id);
            
            // Add new mesh
            const newMesh = this.addElement(elementData);
            
            // Restore selection state
            if (wasSelected) {
                this.setElementSelected(elementData.id, true);
            }
        } else {
            // Element doesn't exist, add it
            this.addElement(elementData);
        }
    }
    
    /**
     * Remove element from scene
     * @param {string} elementId - Element ID
     */
    removeElement(elementId) {
        const mesh = this.elementObjects.get(elementId);
        if (mesh) {
            this.scene.remove(mesh);
            this.elementObjects.delete(elementId);
            
            // Dispose geometry and material
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(mat => mat.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
            
            EventBus.publish('scene:element:removed', { elementId });
        }
    }
    
    /**
     * Set element selection state
     * @param {string} elementId - Element ID
     * @param {boolean} selected - Selection state
     */
    setElementSelected(elementId, selected) {
        const mesh = this.elementObjects.get(elementId);
        if (mesh) {
            mesh.userData.selected = selected;
            
            if (selected) {
                mesh.material = MeshBuilder.getMaterial(
                    mesh.userData.elementData.material, 
                    'selected'
                );
            } else {
                mesh.material = MeshBuilder.getMaterial(
                    mesh.userData.elementData.material, 
                    'element'
                );
            }
        }
    }
    
    /**
     * Rebuild entire scene from data
     */
    rebuildScene() {
        console.time('Scene rebuild');
        
        // Clear existing elements
        this.clearElements();
        
        // Add all elements from data
        strukturaData.elements.forEach(element => {
            this.addElement(element);
        });
        
        // Rebuild grids
        this.rebuildGrids();
        
        console.timeEnd('Scene rebuild');
        
        EventBus.publish('scene:rebuilt', {
            elementCount: strukturaData.elements.length,
            gridCount: strukturaData.grids.length
        });
    }
    
    /**
     * Clear all elements from scene
     */
    clearElements() {
        this.elementObjects.forEach((mesh, elementId) => {
            this.removeElement(elementId);
        });
    }
    
    /**
     * Get element mesh by ID
     * @param {string} elementId - Element ID
     * @returns {THREE.Mesh|null} Element mesh
     */
    getElementMesh(elementId) {
        return this.elementObjects.get(elementId) || null;
    }
    
    /**
     * Get all element meshes
     * @returns {Array<THREE.Mesh>} Array of meshes
     */
    getAllElementMeshes() {
        return Array.from(this.elementObjects.values());
    }
    
    /**
     * Perform raycasting for object selection
     * @param {THREE.Vector2} mousePosition - Normalized mouse coordinates
     * @param {THREE.Camera} camera - Camera for raycasting
     * @returns {Object|null} Intersection result
     */
    raycast(mousePosition, camera) {
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mousePosition, camera);
        
        const meshes = this.getAllElementMeshes();
        const intersections = raycaster.intersectObjects(meshes, true);
        
        if (intersections.length > 0) {
            const closest = intersections[0];
            return {
                elementId: closest.object.userData.elementId,
                mesh: closest.object,
                point: closest.point,
                distance: closest.distance,
                face: closest.face
            };
        }
        
        return null;
    }
}
```

## Performance Optimization

### Level of Detail (LOD)

```javascript
class LODManager {
    static createLODObject(elementData) {
        const lod = new THREE.LOD();
        
        // High detail mesh (close view)
        const highDetailMesh = MeshBuilder.createElement(elementData);
        lod.addLevel(highDetailMesh, 0);
        
        // Medium detail mesh
        const mediumDetailMesh = this.createSimplifiedMesh(elementData, 0.5);
        lod.addLevel(mediumDetailMesh, 2000);
        
        // Low detail mesh (far view)
        const lowDetailMesh = this.createSimplifiedMesh(elementData, 0.1);
        lod.addLevel(lowDetailMesh, 10000);
        
        return lod;
    }
    
    static createSimplifiedMesh(elementData, detail) {
        // Create simplified geometry with reduced vertex count
        const mesh = MeshBuilder.createElement(elementData);
        
        // Simplify geometry
        if (mesh.geometry && detail < 1.0) {
            mesh.geometry = this.simplifyGeometry(mesh.geometry, detail);
        }
        
        return mesh;
    }
    
    static simplifyGeometry(geometry, detail) {
        // Implement geometry simplification
        // This could use libraries like three-mesh-simplifier
        return geometry; // Placeholder
    }
}
```

### Frustum Culling

```javascript
class CullingManager {
    static setupFrustumCulling(camera, scene) {
        const frustum = new THREE.Frustum();
        const matrix = new THREE.Matrix4();
        
        return {
            update() {
                matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                frustum.setFromProjectionMatrix(matrix);
                
                scene.traverse(object => {
                    if (object.isMesh && object.userData.elementId) {
                        object.visible = frustum.intersectsObject(object);
                    }
                });
            }
        };
    }
}
```

## Development Tools

### Three.js Inspector

```javascript
class ThreeJSInspector {
    static inspect(scene) {
        const stats = {
            objects: 0,
            vertices: 0,
            faces: 0,
            materials: new Set(),
            geometries: new Set()
        };
        
        scene.traverse(object => {
            if (object.isMesh) {
                stats.objects++;
                
                if (object.geometry) {
                    stats.geometries.add(object.geometry.uuid);
                    
                    if (object.geometry.attributes.position) {
                        stats.vertices += object.geometry.attributes.position.count;
                    }
                    
                    if (object.geometry.index) {
                        stats.faces += object.geometry.index.count / 3;
                    }
                }
                
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => stats.materials.add(mat.uuid));
                    } else {
                        stats.materials.add(object.material.uuid);
                    }
                }
            }
        });
        
        stats.uniqueMaterials = stats.materials.size;
        stats.uniqueGeometries = stats.geometries.size;
        
        console.table(stats);
        return stats;
    }
    
    static validateScene(scene) {
        const issues = [];
        
        scene.traverse(object => {
            if (object.isMesh) {
                // Check for disposed geometry
                if (object.geometry && object.geometry.attributes.position === undefined) {
                    issues.push(`Disposed geometry on object: ${object.userData.elementId}`);
                }
                
                // Check for missing materials
                if (!object.material) {
                    issues.push(`Missing material on object: ${object.userData.elementId}`);
                }
                
                // Check for NaN positions
                if (isNaN(object.position.x) || isNaN(object.position.y) || isNaN(object.position.z)) {
                    issues.push(`Invalid position on object: ${object.userData.elementId}`);
                }
            }
        });
        
        if (issues.length === 0) {
            console.log('Scene validation passed ✓');
        } else {
            console.error('Scene validation issues:', issues);
        }
        
        return issues;
    }
}

// Development helpers
window.threeDebug = {
    inspect: ThreeJSInspector.inspect,
    validate: ThreeJSInspector.validateScene,
    lod: LODManager,
    materials: () => Array.from(MeshBuilder.materialLibrary.keys()),
    geometries: () => Array.from(MeshBuilder.geometryCache.keys())
};
```

This Three.js integration provides a robust foundation for TomCAD's 3D visualization while maintaining the performance and visual quality needed for professional CAD applications.