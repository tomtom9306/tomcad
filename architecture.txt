1. Architecture Overview
The TomCAD v2 architecture is designed for simplicity, implementation speed, and robustness. Its core is a component-based assembly system driven by a unidirectional data flow. For the MVP, all project modifications trigger a full, "brute-force" regeneration of the model. This approach guarantees data consistency, is highly performant for small-to-medium scale projects, and establishes a clean foundation for future optimizations.

2. Core Data Model
The system is built upon a clear, two-file data model that separates design intent from production-ready output.

project.json (The "Source of Truth"): This file is the complete and sole definition of the user's design. It contains a declarative list of Componentsâ€”parametric objects like Stairs, Beams, or Columns. Each component in the list is assigned a stable, unique ID (id) upon creation. This file also stores all inter-component relationships (references) and manual modifications (overrides). It is the only file the user or the application directly modifies.

parts.json (The "Compiled Output"): This file is the final, production-ready instruction set. It contains an explicit, flat list of every atomic Part (e.g., a single steel plate, a beam profile) and the Operations to be performed on them (e.g., DrillHole, Weld). This file is entirely and exclusively generated by the engine based on project.json. It serves as the single data source for the 3D Renderer, Bill of Materials (BOM), and workshop drawings. Each part within this file has a stable ID derived from its parent component, ensuring predictability (e.g., stairs_01.stringer_left).

3. Component-Based Assembly Engine
The power of TomCAD lies in its engine, which assembles a final structure from a library of independent, reusable components.

3.1. Component Generators (Plugins): Every component type (Beam, Stairs, etc.) is implemented as a self-contained plugin called a Generator. Each Generator contains the logic to produce a list of Parts and Operations based on its input parameters.

3.2. Component Dependencies & Referencing: To create complex structures, components can reference each other. Simple nesting can be used for hierarchical relationships (e.g., a Handrail inside Stairs), but the primary mechanism is referencing via ID. This allows a component to connect to any other component in the project.

Example project.json showing a Beam referencing two Columns:


3.3. Attachment Points: To make referencing robust, Generators must expose logical Attachment Points. These are named, predictable connection points on a component's geometry (e.g., top_center, landing_edge_left). This ensures that connections remain valid even if the component's internal geometry changes, as the Beam generator asks for the logical point, not a hard-coded coordinate.

4. Manual Overrides (The "Safety Valve")
To provide ultimate flexibility, users can manually modify parts generated by a component. This is critical for non-standard details.

Implementation: Overrides are stored as an optional overrides array within the component's data in project.json. This ensures that user modifications are permanent and part of the design intent.

Logic: Each override object specifies a targetPartId (the stable ID of the part to modify, e.g., stairs_01.stringer_left) and a list of modifications (e.g., changing a property) or addOperations (e.g., adding a hole). The Generative Engine applies these overrides after the initial parts have been generated but before the final parts.json is saved.


5. Data Lifecycle: The Generative Engine Flow
The data processing flow is a simple, stateless recompilation loop.

User Action: The user adds a component, changes a parameter, or defines an override. The change is saved to project.json.
Event Fired: A simple PROJECT_CHANGED event is published.
Full Model Recompilation: The Generative Engine listens for the event and rebuilds the entire model from scratch: a. It loads the project.json file. b. It determines the processing order by resolving the component dependencies. c. It executes the Generator for each component. Generators can query the engine for the position of Attachment Points on other, already-processed components they reference. d. It applies any overrides specified in project.json to the in-memory list of generated parts. e. It creates a completely new, final parts.json in memory. f. If any step fails, the process is halted, and the user is notified with a clear error message pointing to the problematic component in project.json.
View Update: The new parts.json is passed to the end modules (3D Renderer, BOM), which rebuild their views from this new source of truth.
This "brute-force" approach is extremely simple to implement and debug. The ID-based system also provides a clear path for future performance optimizations, such as partial ("intelligent") regeneration.

6. Core Workflow: Templates as Project Starters
There are no separate "modes" in TomCAD. The core of the application is a flexible Assembly Editor where the user composes a 3D scene from components.

Project Templates are a key feature that provides immediate value by serving as starting points for this editor. A template is simply a pre-configured project.json file.

Workflow Example: A user wants to model a set of stairs with a custom support beam.
The user selects the "Warehouse Stairs" template.
The application loads the corresponding project.json, which instantly creates a Stairs component in the Assembly Editor.
The user then uses the editor's toolbox to add a new Beam component.
They configure the beam to connect to an Attachment Point on the stairs and another point in the scene.
They receive a production-ready model for the entire assembly.
This workflow combines the speed of templates for common tasks with the complete creative freedom required for real-world fabrication projects.