# Component Registry

## Overview

The ComponentRegistry is TomCAD's **type system** that enables runtime registration and instantiation of extensible components. It serves as the foundation for TomCAD's plugin architecture and allows easy addition of new element types, operations, and UI components.

## Registry Architecture

### Core Registry Class

```javascript
class ComponentRegistry {
    // Static storage for different component categories
    static creators = new Map();
    static operations = new Map();
    static exporters = new Map();
    static importers = new Map();
    static panels = new Map();
    
    // Metadata storage for UI generation
    static metadata = new Map();
    static categories = new Map();
    
    /**
     * Register a component in the specified category
     * @param {string} category - Component category ('creator', 'operation', etc.)
     * @param {string} type - Unique type identifier
     * @param {class} componentClass - Component class to register
     * @param {object} options - Additional registration options
     */
    static register(category, type, componentClass, options = {}) {
        const registry = this.getRegistry(category);
        
        // Validate component class
        this.validateComponent(category, componentClass);
        
        // Store component class
        registry.set(type, componentClass);
        
        // Store metadata for UI generation
        if (componentClass.meta) {
            this.metadata.set(`${category}:${type}`, {
                ...componentClass.meta,
                ...options
            });
        }
        
        // Update category information
        this.updateCategory(category, type, componentClass);
        
        console.log(`[Registry] Registered ${category}: ${type}`);
        
        // Notify system of new registration
        if (typeof EventBus !== 'undefined') {
            EventBus.publish('registry:component:registered', {
                category,
                type,
                componentClass,
                options
            });
        }
        
        return this;
    }
    
    /**
     * Get component class by category and type
     * @param {string} category - Component category
     * @param {string} type - Component type
     * @returns {class|null} Component class or null if not found
     */
    static get(category, type) {
        const registry = this.getRegistry(category);
        return registry.get(type) || null;
    }
    
    /**
     * Create instance of component
     * @param {string} category - Component category
     * @param {string} type - Component type
     * @param {...any} args - Constructor arguments
     * @returns {object} Component instance
     */
    static create(category, type, ...args) {
        const ComponentClass = this.get(category, type);
        if (!ComponentClass) {
            throw new Error(`Component not found: ${category}:${type}`);
        }
        
        return new ComponentClass(...args);
    }
    
    /**
     * Get all components in a category
     * @param {string} category - Component category
     * @returns {Map} Map of type -> class
     */
    static getAll(category) {
        return new Map(this.getRegistry(category));
    }
    
    /**
     * Get component types in category
     * @param {string} category - Component category
     * @returns {string[]} Array of type names
     */
    static getTypes(category) {
        return Array.from(this.getRegistry(category).keys());
    }
    
    /**
     * Get component metadata
     * @param {string} category - Component category
     * @param {string} type - Component type
     * @returns {object|null} Metadata object
     */
    static getMeta(category, type) {
        return this.metadata.get(`${category}:${type}`) || null;
    }
    
    /**
     * Check if component exists
     * @param {string} category - Component category
     * @param {string} type - Component type
     * @returns {boolean} True if component exists
     */
    static has(category, type) {
        return this.getRegistry(category).has(type);
    }
    
    /**
     * Unregister a component
     * @param {string} category - Component category
     * @param {string} type - Component type
     * @returns {boolean} True if component was removed
     */
    static unregister(category, type) {
        const registry = this.getRegistry(category);
        const removed = registry.delete(type);
        
        if (removed) {
            this.metadata.delete(`${category}:${type}`);
            console.log(`[Registry] Unregistered ${category}: ${type}`);
            
            if (typeof EventBus !== 'undefined') {
                EventBus.publish('registry:component:unregistered', {
                    category,
                    type
                });
            }
        }
        
        return removed;
    }
    
    /**
     * Get registry map for category
     * @param {string} category - Component category
     * @returns {Map} Registry map
     * @private
     */
    static getRegistry(category) {
        switch (category) {
            case 'creator': return this.creators;
            case 'operation': return this.operations;
            case 'exporter': return this.exporters;
            case 'importer': return this.importers;
            case 'panel': return this.panels;
            default:
                throw new Error(`Unknown registry category: ${category}`);
        }
    }
    
    /**
     * Validate component class structure
     * @param {string} category - Component category
     * @param {class} componentClass - Component class to validate
     * @private
     */
    static validateComponent(category, componentClass) {
        if (typeof componentClass !== 'function') {
            throw new Error('Component must be a class/constructor function');
        }
        
        // Category-specific validation
        switch (category) {
            case 'creator':
                this.validateCreator(componentClass);
                break;
            case 'operation':
                this.validateOperation(componentClass);
                break;
            case 'exporter':
                this.validateExporter(componentClass);
                break;
        }
    }
    
    /**
     * Update category information
     * @param {string} category - Component category
     * @param {string} type - Component type
     * @param {class} componentClass - Component class
     * @private
     */
    static updateCategory(category, type, componentClass) {
        if (!this.categories.has(category)) {
            this.categories.set(category, {
                count: 0,
                types: [],
                displayCategories: new Set()
            });
        }
        
        const categoryInfo = this.categories.get(category);
        categoryInfo.count++;
        categoryInfo.types.push(type);
        
        // Track display categories from metadata
        if (componentClass.meta && componentClass.meta.category) {
            categoryInfo.displayCategories.add(componentClass.meta.category);
        }
    }
}
```

## Creator Registration

### Creator Validation

```javascript
static validateCreator(componentClass) {
    // Must have meta property
    if (!componentClass.meta) {
        throw new Error('Creator must have static meta property');
    }
    
    const meta = componentClass.meta;
    
    // Required meta fields
    const required = ['type', 'name', 'steps'];
    required.forEach(field => {
        if (!meta[field]) {
            throw new Error(`Creator meta missing required field: ${field}`);
        }
    });
    
    // Must have getUI static method
    if (typeof componentClass.getUI !== 'function') {
        throw new Error('Creator must have static getUI() method');
    }
    
    // Prototype must extend BaseCreator
    if (!componentClass.prototype || 
        typeof componentClass.prototype.execute !== 'function') {
        throw new Error('Creator must extend BaseCreator and implement execute()');
    }
}
```

### Creator Registration Example

```javascript
// Define creator class
class CustomBeamCreator extends BaseCreator {
    static meta = {
        type: 'custom_beam',
        name: 'Custom Beam',
        icon: 'custom-beam-icon',
        category: 'structural',
        description: 'Create custom beam with special properties',
        steps: ['start_point', 'end_point', 'properties'],
        version: '1.0.0',
        author: 'Plugin Developer'
    };
    
    static getUI() {
        return [
            { id: 'profile', type: 'profile', label: 'Steel Profile', value: 'IPE200' },
            { id: 'material', type: 'material', label: 'Material', value: 'S355JR' },
            { id: 'customProperty', type: 'number', label: 'Custom Value', value: 100 }
        ];
    }
    
    static getEditUI(elementData) {
        return this.getUI(); // Same UI for editing
    }
    
    execute() {
        // Implementation...
    }
}

// Register creator
ComponentRegistry.register('creator', 'custom_beam', CustomBeamCreator, {
    priority: 1,
    experimental: false
});
```

## Operation Registration

### Operation Validation

```javascript
static validateOperation(componentClass) {
    if (!componentClass.meta) {
        throw new Error('Operation must have static meta property');
    }
    
    const meta = componentClass.meta;
    const required = ['type', 'name', 'targetTypes'];
    required.forEach(field => {
        if (!meta[field]) {
            throw new Error(`Operation meta missing required field: ${field}`);
        }
    });
    
    // Must have apply method
    if (typeof componentClass.prototype.apply !== 'function') {
        throw new Error('Operation must implement apply() method');
    }
}
```

### Operation Registration Example

```javascript
class AdvancedHoleOperation extends BaseOperation {
    static meta = {
        type: 'advanced_hole',
        name: 'Advanced Hole',
        description: 'Create holes with custom shapes and parameters',
        targetTypes: ['beam', 'column', 'plate'],
        category: 'cutting'
    };
    
    static getUI() {
        return [
            { id: 'shape', type: 'dropdown', label: 'Shape', 
              options: ['circle', 'square', 'slot'], value: 'circle' },
            { id: 'diameter', type: 'number', label: 'Diameter (mm)', value: 20 },
            { id: 'depth', type: 'number', label: 'Depth (mm)', value: 100 }
        ];
    }
    
    apply(geometry) {
        // Implementation...
    }
}

ComponentRegistry.register('operation', 'advanced_hole', AdvancedHoleOperation);
```

## UI Generation from Registry

### Toolbar Generation

```javascript
class ToolbarGenerator {
    static generateFromRegistry() {
        const toolbar = {
            categories: {},
            tools: []
        };
        
        // Generate creator tools
        ComponentRegistry.getAll('creator').forEach((CreatorClass, type) => {
            const meta = ComponentRegistry.getMeta('creator', type);
            
            if (meta) {
                const tool = {
                    id: type,
                    name: meta.name,
                    icon: meta.icon || 'default-icon',
                    category: meta.category || 'misc',
                    description: meta.description || '',
                    type: 'creator'
                };
                
                toolbar.tools.push(tool);
                
                // Group by category
                if (!toolbar.categories[tool.category]) {
                    toolbar.categories[tool.category] = [];
                }
                toolbar.categories[tool.category].push(tool);
            }
        });
        
        return toolbar;
    }
    
    static generateContextMenu(elementType) {
        const menu = [];
        
        // Get applicable operations
        ComponentRegistry.getAll('operation').forEach((OperationClass, type) => {
            const meta = ComponentRegistry.getMeta('operation', type);
            
            if (meta && meta.targetTypes.includes(elementType)) {
                menu.push({
                    id: type,
                    name: meta.name,
                    icon: meta.icon,
                    action: () => this.applyOperation(type, elementType)
                });
            }
        });
        
        return menu;
    }
}
```

### Dynamic Panel Generation

```javascript
class PanelGenerator {
    static generateCreationPanel(creatorType) {
        const CreatorClass = ComponentRegistry.get('creator', creatorType);
        if (!CreatorClass) return null;
        
        const ui = CreatorClass.getUI();
        const meta = ComponentRegistry.getMeta('creator', creatorType);
        
        return {
            title: meta.name,
            description: meta.description,
            fields: ui.map(field => ({
                ...field,
                onChange: (value) => this.handleParameterChange(field.id, value)
            }))
        };
    }
    
    static generateEditPanel(elementData) {
        const CreatorClass = ComponentRegistry.get('creator', elementData.type);
        if (!CreatorClass || typeof CreatorClass.getEditUI !== 'function') {
            return null;
        }
        
        const ui = CreatorClass.getEditUI(elementData);
        
        return {
            title: `Edit ${elementData.type}`,
            elementId: elementData.id,
            fields: ui.map(field => ({
                ...field,
                value: elementData[field.id] || field.value,
                onChange: (value) => this.handleElementUpdate(elementData.id, field.id, value)
            }))
        };
    }
}
```

## Registry Querying and Filtering

### Advanced Queries

```javascript
class RegistryQuery {
    static findByCategory(registryCategory, displayCategory) {
        const results = [];
        
        ComponentRegistry.getAll(registryCategory).forEach((ComponentClass, type) => {
            const meta = ComponentRegistry.getMeta(registryCategory, type);
            
            if (meta && meta.category === displayCategory) {
                results.push({
                    type,
                    class: ComponentClass,
                    meta
                });
            }
        });
        
        return results;
    }
    
    static findCompatibleOperations(elementType) {
        const compatible = [];
        
        ComponentRegistry.getAll('operation').forEach((OperationClass, type) => {
            const meta = ComponentRegistry.getMeta('operation', type);
            
            if (meta && meta.targetTypes.includes(elementType)) {
                compatible.push({
                    type,
                    class: OperationClass,
                    meta
                });
            }
        });
        
        return compatible.sort((a, b) => a.meta.name.localeCompare(b.meta.name));
    }
    
    static search(query, category = null) {
        const results = [];
        const searchTerm = query.toLowerCase();
        
        const categories = category ? [category] : ['creator', 'operation', 'exporter'];
        
        categories.forEach(cat => {
            ComponentRegistry.getAll(cat).forEach((ComponentClass, type) => {
                const meta = ComponentRegistry.getMeta(cat, type);
                
                if (meta) {
                    const searchableText = [
                        meta.name,
                        meta.description,
                        meta.category,
                        type
                    ].join(' ').toLowerCase();
                    
                    if (searchableText.includes(searchTerm)) {
                        results.push({
                            category: cat,
                            type,
                            class: ComponentClass,
                            meta,
                            relevance: this.calculateRelevance(searchableText, searchTerm)
                        });
                    }
                }
            });
        });
        
        return results.sort((a, b) => b.relevance - a.relevance);
    }
    
    static calculateRelevance(text, term) {
        let relevance = 0;
        
        // Exact match in name gets highest score
        if (text.includes(term)) relevance += 10;
        
        // Word boundary matches get medium score
        const words = text.split(' ');
        words.forEach(word => {
            if (word.includes(term)) relevance += 5;
        });
        
        return relevance;
    }
}
```

## Registry Events and Hooks

### Registration Hooks

```javascript
class RegistryHooks {
    static hooks = {
        beforeRegister: [],
        afterRegister: [],
        beforeUnregister: [],
        afterUnregister: []
    };
    
    static addHook(hookName, callback) {
        if (this.hooks[hookName]) {
            this.hooks[hookName].push(callback);
        }
    }
    
    static executeHooks(hookName, data) {
        const hooks = this.hooks[hookName] || [];
        hooks.forEach(callback => {
            try {
                callback(data);
            } catch (error) {
                console.error(`Hook error in ${hookName}:`, error);
            }
        });
    }
}

// Enhanced register method with hooks
const originalRegister = ComponentRegistry.register;
ComponentRegistry.register = function(category, type, componentClass, options = {}) {
    const data = { category, type, componentClass, options };
    
    // Execute before hooks
    RegistryHooks.executeHooks('beforeRegister', data);
    
    // Call original register
    const result = originalRegister.call(this, category, type, componentClass, options);
    
    // Execute after hooks
    RegistryHooks.executeHooks('afterRegister', data);
    
    return result;
};
```

## Registry Persistence and Loading

### Configuration Persistence

```javascript
class RegistryConfig {
    static save() {
        const config = {
            version: '1.0.0',
            timestamp: Date.now(),
            categories: {}
        };
        
        ['creator', 'operation', 'exporter'].forEach(category => {
            config.categories[category] = {};
            
            ComponentRegistry.getAll(category).forEach((ComponentClass, type) => {
                const meta = ComponentRegistry.getMeta(category, type);
                config.categories[category][type] = {
                    enabled: true,
                    meta: meta,
                    priority: meta.priority || 0
                };
            });
        });
        
        localStorage.setItem('tomcad_registry_config', JSON.stringify(config));
        return config;
    }
    
    static load() {
        const configStr = localStorage.getItem('tomcad_registry_config');
        if (!configStr) return null;
        
        try {
            return JSON.parse(configStr);
        } catch (error) {
            console.error('Failed to load registry config:', error);
            return null;
        }
    }
    
    static applyConfig(config) {
        // Disable components that are disabled in config
        Object.entries(config.categories).forEach(([category, types]) => {
            Object.entries(types).forEach(([type, typeConfig]) => {
                if (!typeConfig.enabled) {
                    ComponentRegistry.unregister(category, type);
                }
            });
        });
    }
}
```

## Development Tools

### Registry Inspector

```javascript
class RegistryInspector {
    static inspect() {
        const report = {
            summary: {},
            details: {},
            issues: []
        };
        
        ['creator', 'operation', 'exporter'].forEach(category => {
            const registry = ComponentRegistry.getAll(category);
            report.summary[category] = registry.size;
            report.details[category] = {};
            
            registry.forEach((ComponentClass, type) => {
                const meta = ComponentRegistry.getMeta(category, type);
                report.details[category][type] = {
                    class: ComponentClass.name,
                    meta: meta,
                    hasUI: typeof ComponentClass.getUI === 'function',
                    hasEditUI: typeof ComponentClass.getEditUI === 'function'
                };
                
                // Check for common issues
                if (!meta) {
                    report.issues.push(`${category}:${type} missing metadata`);
                }
                
                if (category === 'creator' && typeof ComponentClass.getUI !== 'function') {
                    report.issues.push(`${category}:${type} missing getUI() method`);
                }
            });
        });
        
        console.table(report.summary);
        console.log('Full Report:', report);
        
        return report;
    }
    
    static validateAll() {
        const issues = [];
        
        ['creator', 'operation', 'exporter'].forEach(category => {
            ComponentRegistry.getAll(category).forEach((ComponentClass, type) => {
                try {
                    ComponentRegistry.validateComponent(category, ComponentClass);
                } catch (error) {
                    issues.push({
                        category,
                        type,
                        error: error.message
                    });
                }
            });
        });
        
        if (issues.length > 0) {
            console.error('Registry validation issues:', issues);
        } else {
            console.log('All components valid ✓');
        }
        
        return issues;
    }
}

// Development helpers
window.registry = {
    inspect: RegistryInspector.inspect,
    validate: RegistryInspector.validateAll,
    query: RegistryQuery,
    config: RegistryConfig
};
```

The ComponentRegistry serves as the backbone of TomCAD's extensible architecture, enabling easy addition of new functionality while maintaining clean separation of concerns and automatic UI generation.