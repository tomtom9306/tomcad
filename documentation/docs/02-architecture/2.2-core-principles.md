# Core Principles

## Architectural Philosophy

TomCAD's architecture is built on fundamental principles that guide all development decisions and ensure consistency across the entire codebase.

## 1. Simplicity First

### Design for Understanding
- **Clear Code Structure**: Every module has a single, obvious purpose
- **Readable Patterns**: Consistent naming and organization throughout
- **Minimal Abstractions**: Avoid over-engineering and complex inheritance hierarchies
- **Direct Relationships**: Prefer explicit dependencies over hidden coupling

### Implementation Examples
```javascript
// Good: Simple, clear responsibility
class BeamCreator extends BaseCreator {
    execute() {
        const elementData = this.collectElementData();
        this.creationManager.createElement(elementData);
    }
}

// Avoid: Over-abstracted, hard to follow
class AbstractParametricElementCreatorFactory {
    createCreatorInstance(type, params, context, metadata) {
        // Complex factory logic...
    }
}
```

## 2. Extensibility by Design

### Plugin-Ready Architecture
- **Component Registry**: Runtime registration enables plugins
- **Event-Driven Communication**: Loose coupling allows new modules
- **Interface Consistency**: Standard patterns for all extensions
- **Metadata-Driven UI**: Automatic UI generation from component definitions

### Extension Patterns
```javascript
// Register new element type
class CustomElementCreator extends BaseCreator {
    static meta = { type: 'custom', name: 'Custom Element' };
    execute() { /* implementation */ }
}

ComponentRegistry.register('creator', 'custom', CustomElementCreator);
// Element automatically appears in UI
```

## 3. Web-Native Approach

### Browser-First Design
- **No Server Dependencies**: Complete client-side functionality
- **Modern Web Standards**: ES6+ modules, WebGL, modern APIs
- **Cross-Platform**: Works on Windows, Mac, Linux, tablets
- **Progressive Enhancement**: Graceful degradation on older browsers

### Technical Benefits
- **Zero Installation**: Runs immediately in browser
- **Always Updated**: No version conflicts or update procedures
- **Easy Deployment**: Simple file hosting requirements
- **Collaborative Ready**: Easy sharing and team access

## 4. Development Priority: Simplicity Over Performance

### Version 1.0 Philosophy
**Development speed and code maintainability take precedence over performance optimization.**

### Why This Approach Works
- **Faster Feature Development**: Simple patterns accelerate implementation
- **Easy Debugging**: Clear structure makes issues obvious
- **Rapid Iteration**: Simple architecture enables quick changes
- **Lower Learning Curve**: New developers can contribute immediately

### Performance Strategy
Performance improvements will be implemented **after** core functionality is stable:

1. **Build Working Software First**: Establish solid feature foundation
2. **Identify Bottlenecks**: Profile real usage patterns
3. **Optimize Systematically**: Target actual performance issues
4. **Maintain Simplicity**: Keep optimizations understandable

### Trade-offs Accepted in V1.0
- **Brute-force scene regeneration** over incremental updates
- **Simple algorithms** over optimized ones  
- **Code clarity** over micro-optimizations
- **Development velocity** over runtime efficiency

## 5. Event-Driven Communication

### Decoupled Architecture
- **EventBus Central Hub**: All inter-module communication via events
- **Loose Coupling**: Modules don't directly reference each other
- **Easy Testing**: Mock events for isolated unit testing
- **Plugin Integration**: External modules integrate via same event system

### Communication Patterns
```javascript
// Publish events for state changes
EventBus.publish('element:created', { elementId, data });

// Subscribe to relevant events
EventBus.subscribe('element:created', this.onElementCreated.bind(this));

// No direct manager references needed
```

## 6. Data-Driven UI Generation

### Configuration Over Code
- **Metadata Definitions**: UI automatically generated from component metadata
- **Consistent Interfaces**: Same UI patterns across all element types
- **Easy Customization**: Change UI by modifying metadata
- **Plugin-Friendly**: External components get UI automatically

### UI Generation Example
```javascript
static getUI() {
    return [
        { id: 'profile', type: 'profile', label: 'Steel Profile' },
        { id: 'material', type: 'material', label: 'Material' }
    ];
    // UI automatically generated from this config
}
```

## 7. Brute-Force Consistency

### Regeneration Over Optimization
- **Full Scene Rebuild**: Regenerate everything when data changes
- **Data Consistency**: Always accurate visual representation
- **Simple Debugging**: No complex state synchronization issues
- **Reliable Updates**: Changes always properly reflected

### Benefits for Development
```javascript
// Simple update pattern
updateElement(elementId, changes) {
    // Update data
    Object.assign(element, changes);
    
    // Regenerate mesh - always consistent
    this.regenerateMesh(elementId);
    
    // No complex state tracking needed
}
```

## 8. Clear Separation of Concerns

### Layer Responsibilities
- **Data Layer**: Pure data structures, no business logic
- **Manager Layer**: Business logic, no UI concerns
- **UI Layer**: User interface, no data manipulation
- **Rendering Layer**: Three.js visualization, no application logic

### No Cross-Layer Dependencies
```javascript
// Good: Clear layer separation
class ElementManager {
    updateElement(id, data) {
        // Data operations only
        strukturaData.elements.update(id, data);
        EventBus.publish('element:updated', { id, data });
    }
}

class EditPanel {
    onElementUpdate(data) {
        // UI updates only
        this.refreshDisplayFields(data);
    }
}
```

## 9. Fail-Fast Development

### Early Error Detection
- **Input Validation**: Validate data at entry points
- **Type Checking**: Runtime type validation where needed
- **Clear Error Messages**: Descriptive errors for debugging
- **Graceful Degradation**: System continues working when possible

### Error Handling Example
```javascript
static validate(elementData) {
    const errors = [];
    
    if (!elementData.profile) {
        errors.push('Profile is required');
    }
    
    if (elementData.length <= 0) {
        errors.push('Length must be positive');
    }
    
    return { valid: errors.length === 0, errors };
}
```

## 10. Future-Proof Foundation

### Designed for Growth
- **Modular Architecture**: Add features without affecting existing code
- **Standard Interfaces**: Consistent patterns enable easy extension
- **Plugin System Ready**: Architecture supports future plugin marketplace
- **Version Migration**: Data structures support schema evolution

### Scalability Considerations
- **Memory Management**: Proper resource cleanup patterns
- **Performance Hooks**: Places for future optimization
- **Configuration System**: Settings for future advanced features
- **API Readiness**: Internal APIs ready for external access

These principles ensure TomCAD remains maintainable and extensible as it grows from a simple drawing tool to a comprehensive steel construction platform.