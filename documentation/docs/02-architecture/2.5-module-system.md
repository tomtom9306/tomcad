# Module System

## Overview

TomCAD uses a **component-based module system** built on ES6 modules with a centralized registry pattern. The system is designed for extensibility, allowing new components to be added without modifying existing code.

## Core Module Architecture

### Module Categories

| Category | Purpose | Examples | Registration |
|----------|---------|----------|-------------|
| **Creators** | Element creation logic | BeamCreator, ColumnCreator | ComponentRegistry |
| **Managers** | Domain-specific coordination | ElementManager, UIManager | Manual initialization |
| **Operations** | Geometric modifications | HoleOperation, CutOperation | OperationRegistry |
| **UI Panels** | User interface components | CreationPanel, EditPanel | UIManager |
| **Exporters** | Data export functionality | IFCExporter, DXFExporter | ExportRegistry |

### Base Module Classes

```javascript
// Base class for all components
class BaseComponent {
    constructor(core) {
        this.core = core;
        this.id = this.generateId();
        this.initialized = false;
    }
    
    initialize() {
        this.initialized = true;
        return this;
    }
    
    destroy() {
        this.initialized = false;
    }
    
    generateId() {
        return `${this.constructor.name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

// Base class for managers
class Manager extends BaseComponent {
    constructor(core) {
        super(core);
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // Override in subclasses
    }
}
```

## Component Registry System

### ComponentRegistry Implementation

```javascript
class ComponentRegistry {
    static creators = new Map();
    static operations = new Map();
    static exporters = new Map();
    static metadata = new Map();
    
    // Register a new component type
    static register(category, type, componentClass) {
        const registry = this.getRegistry(category);
        registry.set(type, componentClass);
        
        // Store metadata for UI generation
        if (componentClass.meta) {
            this.metadata.set(`${category}:${type}`, componentClass.meta);
        }
        
        console.log(`[Registry] Registered ${category}: ${type}`);
        return this;
    }
    
    // Get component class by type
    static get(category, type) {
        const registry = this.getRegistry(category);
        return registry.get(type);
    }
    
    // Get all components in category
    static getAll(category) {
        const registry = this.getRegistry(category);
        return Array.from(registry.entries());
    }
    
    // Get registry by category
    static getRegistry(category) {
        switch (category) {
            case 'creator': return this.creators;
            case 'operation': return this.operations;
            case 'exporter': return this.exporters;
            default: throw new Error(`Unknown registry category: ${category}`);
        }
    }
    
    // Generate UI configuration from registered components
    static generateToolbar() {
        const toolbar = [];
        
        this.creators.forEach((creatorClass, type) => {
            if (creatorClass.meta) {
                toolbar.push({
                    type: type,
                    name: creatorClass.meta.name,
                    icon: creatorClass.meta.icon,
                    category: creatorClass.meta.category || 'elements'
                });
            }
        });
        
        return toolbar;
    }
}
```

### Module Registration Pattern

```javascript
// Creator registration example
class BeamCreator extends BaseCreator {
    static meta = {
        type: 'beam',
        name: 'Beam',
        icon: 'beam-icon',
        category: 'structural',
        description: 'Create structural steel beams',
        steps: ['start_point', 'end_point', 'properties']
    };
    
    static getUI() {
        return [
            { id: 'profile', type: 'profile', label: 'Steel Profile', value: 'IPE200' },
            { id: 'material', type: 'material', label: 'Material', value: 'S355JR' },
            { id: 'rotation', type: 'number', label: 'Rotation (Â°)', value: 0 }
        ];
    }
    
    // ... implementation
}

// Register the creator
ComponentRegistry.register('creator', 'beam', BeamCreator);
```

## Module Lifecycle

### Initialization Sequence

```javascript
class ModuleSystem {
    static async initialize() {
        console.log('[ModuleSystem] Starting initialization...');
        
        // 1. Initialize core systems
        await this.initializeCore();
        
        // 2. Register built-in components
        await this.registerBuiltinComponents();
        
        // 3. Load plugin modules
        await this.loadPlugins();
        
        // 4. Initialize managers
        await this.initializeManagers();
        
        // 5. Generate UI from registered components
        await this.generateUI();
        
        console.log('[ModuleSystem] Initialization complete');
    }
    
    static async registerBuiltinComponents() {
        // Creators
        ComponentRegistry.register('creator', 'beam', BeamCreator);
        ComponentRegistry.register('creator', 'column', ColumnCreator);
        ComponentRegistry.register('creator', 'goalpost', GoalPostCreator);
        
        // Operations
        ComponentRegistry.register('operation', 'hole', HoleOperation);
        ComponentRegistry.register('operation', 'slot', SlotOperation);
        ComponentRegistry.register('operation', 'cut', RectCutOperation);
        
        // Exporters
        ComponentRegistry.register('exporter', 'ifc', IFCExporter);
        ComponentRegistry.register('exporter', 'dxf', DXFExporter);
    }
}
```

### Dynamic Module Loading

```javascript
// Future plugin system implementation
class PluginLoader {
    static async loadPlugin(pluginUrl) {
        try {
            // Dynamic import of plugin module
            const plugin = await import(pluginUrl);
            
            // Validate plugin structure
            if (!plugin.default || !plugin.default.register) {
                throw new Error('Invalid plugin structure');
            }
            
            // Register plugin components
            await plugin.default.register(ComponentRegistry);
            
            console.log(`[PluginLoader] Loaded plugin: ${plugin.default.name}`);
            return plugin.default;
        } catch (error) {
            console.error(`[PluginLoader] Failed to load plugin ${pluginUrl}:`, error);
            throw error;
        }
    }
    
    static async loadPluginsFromConfig(config) {
        const promises = config.plugins.map(url => this.loadPlugin(url));
        return Promise.allSettled(promises);
    }
}
```

## Creator Module Pattern

### Creator Interface

```javascript
class BaseCreator {
    // Static metadata for registration
    static meta = {
        type: '',           // Unique identifier
        name: '',           // Display name
        icon: '',           // UI icon
        category: '',       // Toolbar category
        description: '',    // Tooltip description
        steps: []           // Creation steps
    };
    
    // UI configuration
    static getUI() {
        return []; // Array of UI control definitions
    }
    
    // Edit UI configuration
    static getEditUI(elementData) {
        return []; // Array of edit control definitions
    }
    
    // Control points for manipulation
    static getControlPoints(elementData) {
        return []; // Array of control point definitions
    }
    
    // Instance methods
    constructor(creationManager) {
        this.creationManager = creationManager;
        this.reset();
    }
    
    reset() {
        this.currentStep = 0;
        this.data = {};
        this.preview = null;
    }
    
    // Handle mouse events
    onMouseDown(event) {}
    onMouseMove(event) {}
    onMouseUp(event) {}
    
    // Handle keyboard events
    onKeyDown(event) {}
    
    // Execute creation
    execute() {
        // Abstract method - implement in subclasses
        throw new Error('execute() must be implemented');
    }
    
    // Should continue creating after completion
    shouldRestart() {
        return true; // Default: continue creating
    }
    
    // Cleanup
    destroy() {
        if (this.preview) {
            this.creationManager.removePreview(this.preview);
        }
    }
}
```

### Creator Example Implementation

```javascript
class StairsCreator extends BaseCreator {
    static meta = {
        type: 'stairs',
        name: 'Steel Stairs',
        icon: 'stairs-icon',
        category: 'structural',
        description: 'Create steel stairs with railings',
        steps: ['start_point', 'end_point', 'configuration']
    };
    
    static getUI() {
        return [
            { id: 'steps', type: 'number', label: 'Number of Steps', value: 12, min: 3, max: 30 },
            { id: 'width', type: 'number', label: 'Width (mm)', value: 1000, min: 600, max: 2000 },
            { id: 'railing', type: 'checkbox', label: 'Include Railings', value: true },
            { id: 'platform', type: 'checkbox', label: 'Include Platform', value: false }
        ];
    }
    
    onMouseDown(event) {
        const point = this.creationManager.getWorldPosition(event);
        
        switch (this.currentStep) {
            case 0: // Start point
                this.data.startPoint = point;
                this.currentStep = 1;
                this.updatePreview();
                break;
                
            case 1: // End point
                this.data.endPoint = point;
                this.currentStep = 2;
                this.execute();
                break;
        }
    }
    
    execute() {
        const elementData = {
            type: 'stairs',
            startPoint: this.data.startPoint,
            endPoint: this.data.endPoint,
            steps: this.getParameterValue('steps'),
            width: this.getParameterValue('width'),
            includeRailing: this.getParameterValue('railing'),
            includePlatform: this.getParameterValue('platform')
        };
        
        this.creationManager.createElement(elementData);
        
        if (this.shouldRestart()) {
            this.reset();
        }
    }
}

// Register the creator
ComponentRegistry.register('creator', 'stairs', StairsCreator);
```

## Operation Module Pattern

### Operation Interface

```javascript
class BaseOperation {
    static meta = {
        type: '',
        name: '',
        description: '',
        targetTypes: [] // Element types this operation can be applied to
    };
    
    constructor(targetElement, parameters) {
        this.targetElement = targetElement;
        this.parameters = parameters;
        this.id = this.generateId();
    }
    
    // Apply operation to element geometry
    apply(geometry) {
        throw new Error('apply() must be implemented');
    }
    
    // Get UI for operation parameters
    static getUI() {
        return [];
    }
    
    // Validate operation parameters
    validate() {
        return { valid: true, errors: [] };
    }
    
    generateId() {
        return `${this.constructor.meta.type.toUpperCase()}_${Date.now()}`;
    }
}
```

### Operation Example

```javascript
class HoleOperation extends BaseOperation {
    static meta = {
        type: 'hole',
        name: 'Hole',
        description: 'Create circular holes in elements',
        targetTypes: ['beam', 'column', 'plate']
    };
    
    static getUI() {
        return [
            { id: 'diameter', type: 'number', label: 'Diameter (mm)', value: 20, min: 5, max: 100 },
            { id: 'position', type: 'point', label: 'Position', value: [0, 0, 0] }
        ];
    }
    
    apply(geometry) {
        // Create hole geometry using CSG operations
        const hole = new THREE.CylinderGeometry(
            this.parameters.diameter / 2,
            this.parameters.diameter / 2,
            geometry.thickness + 10, // Slightly thicker to ensure clean cut
            16
        );
        
        // Position hole
        hole.translate(
            this.parameters.position[0],
            this.parameters.position[1],
            this.parameters.position[2]
        );
        
        // Subtract hole from geometry (CSG operation)
        return this.performCSGSubtraction(geometry, hole);
    }
    
    validate() {
        const errors = [];
        
        if (this.parameters.diameter <= 0) {
            errors.push('Diameter must be positive');
        }
        
        if (this.parameters.diameter > this.targetElement.profile.height) {
            errors.push('Hole diameter exceeds element height');
        }
        
        return {
            valid: errors.length === 0,
            errors: errors
        };
    }
}

ComponentRegistry.register('operation', 'hole', HoleOperation);
```

## Module Communication

### Event-Based Communication

```javascript
// Modules communicate via EventBus
class CreationManager extends Manager {
    setupEventListeners() {
        EventBus.subscribe('creator:selected', this.onCreatorSelected.bind(this));
        EventBus.subscribe('element:created', this.onElementCreated.bind(this));
        EventBus.subscribe('ui:parameter:changed', this.onParameterChanged.bind(this));
    }
    
    startCreation(type) {
        const CreatorClass = ComponentRegistry.get('creator', type);
        if (!CreatorClass) {
            throw new Error(`Unknown creator type: ${type}`);
        }
        
        this.activeCreator = new CreatorClass(this);
        EventBus.publish('creation:started', { type, creator: this.activeCreator });
    }
}
```

### Module Dependencies

```javascript
// Dependency injection pattern
class ModuleDependency {
    static resolve(moduleClass) {
        const dependencies = moduleClass.dependencies || [];
        const resolved = {};
        
        dependencies.forEach(dep => {
            resolved[dep] = this.getInstance(dep);
        });
        
        return resolved;
    }
    
    static getInstance(type) {
        // Return singleton instance of manager/service
        return this.instances.get(type);
    }
}

// Example module with dependencies
class ElementManager extends Manager {
    static dependencies = ['gridManager', 'operationManager'];
    
    constructor(core, dependencies) {
        super(core);
        this.gridManager = dependencies.gridManager;
        this.operationManager = dependencies.operationManager;
    }
}
```

## Module Configuration

### Configuration System

```javascript
class ModuleConfig {
    static config = {
        creators: {
            enableAll: true,
            disabled: [],
            customPath: null
        },
        operations: {
            enableCSG: true,
            precision: 0.01
        },
        ui: {
            showAdvanced: false,
            theme: 'default'
        }
    };
    
    static get(path) {
        return path.split('.').reduce((obj, key) => obj[key], this.config);
    }
    
    static set(path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((obj, key) => obj[key], this.config);
        target[lastKey] = value;
    }
}
```

## Extension and Plugin System

### Plugin Interface

```javascript
class Plugin {
    constructor(name, version) {
        this.name = name;
        this.version = version;
        this.components = [];
    }
    
    // Plugin registration method
    register(registry) {
        this.components.forEach(component => {
            registry.register(component.category, component.type, component.class);
        });
    }
    
    // Plugin lifecycle hooks
    onLoad() {}
    onUnload() {}
    onActivate() {}
    onDeactivate() {}
}

// Example plugin
class CustomStairsPlugin extends Plugin {
    constructor() {
        super('Custom Stairs', '1.0.0');
        
        this.components = [
            {
                category: 'creator',
                type: 'spiral_stairs',
                class: SpiralStairsCreator
            },
            {
                category: 'operation', 
                type: 'landing_platform',
                class: LandingPlatformOperation
            }
        ];
    }
}
```

This module system provides a robust foundation for TomCAD's extensible architecture while maintaining simplicity and ease of development.