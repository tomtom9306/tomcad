# Creator Pattern

## Overview

The Creator Pattern in TomCAD provides a **unified interface** for creating different types of structural elements. Each creator handles the complete workflow from user interaction to element generation, ensuring consistency across all element types while allowing for type-specific behavior.

## Creator Architecture

### Base Creator Interface

```javascript
class BaseCreator {
    // Static metadata for registration and UI generation
    static meta = {
        type: '',           // Unique type identifier (e.g., 'beam', 'column')
        name: '',           // Display name for UI
        icon: '',           // Icon identifier for toolbar
        category: '',       // Toolbar category grouping
        description: '',    // Tooltip description
        steps: [],          // Array of creation step names
        version: '1.0.0',   // Creator version
        author: ''          // Creator author/plugin name
    };
    
    /**
     * Static UI configuration method
     * @returns {Array} Array of UI control definitions
     */
    static getUI() {
        return []; // Override in subclasses
    }
    
    /**
     * Static edit UI configuration method
     * @param {Object} elementData - Element data for editing
     * @returns {Array} Array of edit control definitions
     */
    static getEditUI(elementData) {
        return this.getUI(); // Default: same as creation UI
    }
    
    /**
     * Get control points for element manipulation
     * @param {Object} elementData - Element data
     * @returns {Array} Array of control point definitions
     */
    static getControlPoints(elementData) {
        return []; // Override in subclasses
    }
    
    /**
     * Validate element data
     * @param {Object} elementData - Element data to validate
     * @returns {Object} Validation result {valid: boolean, errors: Array}
     */
    static validate(elementData) {
        return { valid: true, errors: [] };
    }
    
    // Instance properties and methods
    constructor(creationManager) {
        this.creationManager = creationManager;
        this.currentStep = 0;
        this.stepData = {};
        this.parameters = {};
        this.preview = null;
        this.isActive = false;
        
        this.initialize();
    }
    
    /**
     * Initialize creator instance
     */
    initialize() {
        this.reset();
        this.setupUI();
        this.isActive = true;
    }
    
    /**
     * Reset creator to initial state
     */
    reset() {
        this.currentStep = 0;
        this.stepData = {};
        this.clearPreview();
        
        // Initialize parameters with default values
        const ui = this.constructor.getUI();
        ui.forEach(control => {
            if (control.value !== undefined) {
                this.parameters[control.id] = control.value;
            }
        });
    }
    
    /**
     * Handle mouse down events
     * @param {Object} event - Mouse event data
     */
    onMouseDown(event) {
        if (!this.isActive) return;
        
        const currentStepName = this.constructor.meta.steps[this.currentStep];
        this.handleStep(currentStepName, event);
    }
    
    /**
     * Handle mouse move events
     * @param {Object} event - Mouse event data
     */
    onMouseMove(event) {
        if (!this.isActive) return;
        this.updatePreview(event);
    }
    
    /**
     * Handle mouse up events
     * @param {Object} event - Mouse event data
     */
    onMouseUp(event) {
        // Override in subclasses if needed
    }
    
    /**
     * Handle keyboard events
     * @param {Object} event - Keyboard event data
     */
    onKeyDown(event) {
        if (event.key === 'Escape') {
            this.cancel();
        } else if (event.key === 'Enter') {
            this.completeCurrentStep();
        }
    }
    
    /**
     * Handle creation step
     * @param {string} stepName - Name of current step
     * @param {Object} event - Event data
     */
    handleStep(stepName, event) {
        // Override in subclasses
        throw new Error('handleStep() must be implemented in subclass');
    }
    
    /**
     * Execute element creation
     */
    execute() {
        // Override in subclasses
        throw new Error('execute() must be implemented in subclass');
    }
    
    /**
     * Update preview visualization
     * @param {Object} event - Event data for preview update
     */
    updatePreview(event) {
        // Override in subclasses if preview is needed
    }
    
    /**
     * Clear preview visualization
     */
    clearPreview() {
        if (this.preview) {
            this.creationManager.removePreview(this.preview);
            this.preview = null;
        }
    }
    
    /**
     * Complete current creation step
     */
    completeCurrentStep() {
        if (this.currentStep < this.constructor.meta.steps.length - 1) {
            this.currentStep++;
            this.onStepChanged();
        } else {
            this.execute();
        }
    }
    
    /**
     * Go back to previous step
     */
    previousStep() {
        if (this.currentStep > 0) {
            this.currentStep--;
            this.onStepChanged();
        }
    }
    
    /**
     * Handle step change
     */
    onStepChanged() {
        EventBus.publish('creation:step:changed', {
            creator: this,
            currentStep: this.currentStep,
            stepName: this.constructor.meta.steps[this.currentStep]
        });
    }
    
    /**
     * Cancel creation
     */
    cancel() {
        this.clearPreview();
        this.isActive = false;
        
        EventBus.publish('creation:cancelled', {
            type: this.constructor.meta.type
        });
    }
    
    /**
     * Check if should restart after creation
     * @returns {boolean}
     */
    shouldRestart() {
        return true; // Default: continue creating same type
    }
    
    /**
     * Get parameter value
     * @param {string} parameterId - Parameter identifier
     * @returns {*} Parameter value
     */
    getParameterValue(parameterId) {
        return this.parameters[parameterId];
    }
    
    /**
     * Set parameter value
     * @param {string} parameterId - Parameter identifier
     * @param {*} value - New value
     */
    setParameterValue(parameterId, value) {
        this.parameters[parameterId] = value;
        this.onParameterChanged(parameterId, value);
    }
    
    /**
     * Handle parameter change
     * @param {string} parameterId - Parameter identifier
     * @param {*} value - New value
     */
    onParameterChanged(parameterId, value) {
        // Update preview if it exists
        if (this.preview) {
            this.updatePreview();
        }
        
        EventBus.publish('creation:parameter:changed', {
            creator: this,
            parameterId,
            value
        });
    }
    
    /**
     * Setup UI for creator
     */
    setupUI() {
        const ui = this.constructor.getUI();
        
        EventBus.publish('ui:creator:setup', {
            type: this.constructor.meta.type,
            ui: ui,
            meta: this.constructor.meta
        });
    }
    
    /**
     * Clean up creator resources
     */
    destroy() {
        this.clearPreview();
        this.isActive = false;
    }
}
```

## Creator Implementation Examples

### Simple Creator - Column

```javascript
class ColumnCreator extends BaseCreator {
    static meta = {
        type: 'column',
        name: 'Column',
        icon: 'column-icon',
        category: 'structural',
        description: 'Create vertical structural columns',
        steps: ['position', 'height', 'properties']
    };
    
    static getUI() {
        return [
            { 
                id: 'profile', 
                type: 'profile', 
                label: 'Steel Profile', 
                value: 'HEA200',
                filter: 'columns' // Only show profiles suitable for columns
            },
            { 
                id: 'material', 
                type: 'material', 
                label: 'Material', 
                value: 'S355JR' 
            },
            { 
                id: 'height', 
                type: 'number', 
                label: 'Height (mm)', 
                value: 3000, 
                min: 100, 
                max: 15000 
            },
            { 
                id: 'rotation', 
                type: 'number', 
                label: 'Rotation (Â°)', 
                value: 0, 
                min: 0, 
                max: 360 
            }
        ];
    }
    
    static getControlPoints(elementData) {
        return [
            {
                id: 'base',
                position: elementData.position,
                type: 'move',
                constraint: 'xy' // Only allow XY movement
            },
            {
                id: 'top',
                position: [
                    elementData.position[0],
                    elementData.position[1],
                    elementData.position[2] + elementData.height
                ],
                type: 'resize',
                constraint: 'z' // Only allow Z movement
            }
        ];
    }
    
    handleStep(stepName, event) {
        const worldPos = this.creationManager.getWorldPosition(event);
        
        switch (stepName) {
            case 'position':
                this.stepData.position = worldPos;
                this.completeCurrentStep();
                break;
                
            case 'height':
                // Height is set via UI parameter
                this.completeCurrentStep();
                break;
                
            case 'properties':
                // Properties are set via UI
                this.execute();
                break;
        }
    }
    
    updatePreview(event) {
        if (this.currentStep === 0) return; // No preview before position is set
        
        const previewData = {
            type: 'column',
            position: this.stepData.position,
            height: this.getParameterValue('height'),
            profile: this.getParameterValue('profile'),
            material: this.getParameterValue('material'),
            rotation: this.getParameterValue('rotation')
        };
        
        this.preview = this.creationManager.updatePreview(this.preview, previewData);
    }
    
    execute() {
        const elementData = {
            type: 'column',
            position: this.stepData.position,
            height: this.getParameterValue('height'),
            profile: this.getParameterValue('profile'),
            material: this.getParameterValue('material'),
            rotation: this.getParameterValue('rotation')
        };
        
        // Validate before creation
        const validation = this.constructor.validate(elementData);
        if (!validation.valid) {
            EventBus.publish('ui:error', {
                message: 'Invalid column parameters',
                errors: validation.errors
            });
            return;
        }
        
        this.creationManager.createElement(elementData);
        
        if (this.shouldRestart()) {
            this.reset();
        }
    }
    
    static validate(elementData) {
        const errors = [];
        
        if (!elementData.position || elementData.position.length !== 3) {
            errors.push('Invalid position');
        }
        
        if (!elementData.height || elementData.height <= 0) {
            errors.push('Height must be positive');
        }
        
        if (elementData.height > 15000) {
            errors.push('Height exceeds maximum (15000mm)');
        }
        
        if (!elementData.profile) {
            errors.push('Profile is required');
        }
        
        return {
            valid: errors.length === 0,
            errors: errors
        };
    }
}

// Register the creator
ComponentRegistry.register('creator', 'column', ColumnCreator);
```

### Complex Creator - Beam

```javascript
class BeamCreator extends BaseCreator {
    static meta = {
        type: 'beam',
        name: 'Beam',
        icon: 'beam-icon',
        category: 'structural',
        description: 'Create horizontal structural beams',
        steps: ['start_point', 'end_point', 'properties']
    };
    
    static getUI() {
        return [
            { 
                id: 'profile', 
                type: 'profile', 
                label: 'Steel Profile', 
                value: 'IPE200',
                filter: 'beams'
            },
            { 
                id: 'material', 
                type: 'material', 
                label: 'Material', 
                value: 'S355JR' 
            },
            { 
                id: 'rotation', 
                type: 'number', 
                label: 'Rotation (Â°)', 
                value: 0 
            },
            {
                id: 'attachToGrid',
                type: 'checkbox',
                label: 'Attach to Grid',
                value: true
            }
        ];
    }
    
    static getControlPoints(elementData) {
        return [
            {
                id: 'start',
                position: elementData.startPoint,
                type: 'move',
                constraint: 'none'
            },
            {
                id: 'end',
                position: elementData.endPoint,
                type: 'move',
                constraint: 'none'
            },
            {
                id: 'middle',
                position: [
                    (elementData.startPoint[0] + elementData.endPoint[0]) / 2,
                    (elementData.startPoint[1] + elementData.endPoint[1]) / 2,
                    (elementData.startPoint[2] + elementData.endPoint[2]) / 2
                ],
                type: 'move',
                constraint: 'perpendicular' // Move perpendicular to beam axis
            }
        ];
    }
    
    handleStep(stepName, event) {
        const worldPos = this.creationManager.getWorldPosition(event);
        
        // Apply grid snapping if enabled
        if (this.getParameterValue('attachToGrid')) {
            const snappedPos = this.creationManager.snapToGrid(worldPos);
            if (snappedPos.snapped) {
                worldPos[0] = snappedPos.point[0];
                worldPos[1] = snappedPos.point[1];
                worldPos[2] = snappedPos.point[2];
            }
        }
        
        switch (stepName) {
            case 'start_point':
                this.stepData.startPoint = worldPos;
                this.completeCurrentStep();
                break;
                
            case 'end_point':
                this.stepData.endPoint = worldPos;
                this.completeCurrentStep();
                break;
                
            case 'properties':
                this.execute();
                break;
        }
    }
    
    updatePreview(event) {
        if (this.currentStep === 0) return;
        
        let endPoint = this.stepData.endPoint;
        
        // If we're still in step 1, use mouse position as end point
        if (this.currentStep === 1 && event) {
            endPoint = this.creationManager.getWorldPosition(event);
            
            if (this.getParameterValue('attachToGrid')) {
                const snappedPos = this.creationManager.snapToGrid(endPoint);
                if (snappedPos.snapped) {
                    endPoint = snappedPos.point;
                }
            }
        }
        
        if (!endPoint) return;
        
        const previewData = {
            type: 'beam',
            startPoint: this.stepData.startPoint,
            endPoint: endPoint,
            profile: this.getParameterValue('profile'),
            material: this.getParameterValue('material'),
            rotation: this.getParameterValue('rotation')
        };
        
        this.preview = this.creationManager.updatePreview(this.preview, previewData);
    }
    
    execute() {
        const elementData = {
            type: 'beam',
            startPoint: this.stepData.startPoint,
            endPoint: this.stepData.endPoint,
            profile: this.getParameterValue('profile'),
            material: this.getParameterValue('material'),
            rotation: this.getParameterValue('rotation')
        };
        
        // Add grid attachments if enabled
        if (this.getParameterValue('attachToGrid')) {
            elementData.gridAttachments = {
                start: this.creationManager.getGridAttachment(elementData.startPoint),
                end: this.creationManager.getGridAttachment(elementData.endPoint)
            };
        }
        
        const validation = this.constructor.validate(elementData);
        if (!validation.valid) {
            EventBus.publish('ui:error', {
                message: 'Invalid beam parameters',
                errors: validation.errors
            });
            return;
        }
        
        this.creationManager.createElement(elementData);
        
        if (this.shouldRestart()) {
            this.reset();
        }
    }
    
    static validate(elementData) {
        const errors = [];
        
        if (!elementData.startPoint || elementData.startPoint.length !== 3) {
            errors.push('Invalid start point');
        }
        
        if (!elementData.endPoint || elementData.endPoint.length !== 3) {
            errors.push('Invalid end point');
        }
        
        // Check beam length
        if (elementData.startPoint && elementData.endPoint) {
            const dx = elementData.endPoint[0] - elementData.startPoint[0];
            const dy = elementData.endPoint[1] - elementData.startPoint[1];
            const dz = elementData.endPoint[2] - elementData.startPoint[2];
            const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if (length < 100) {
                errors.push('Beam length too short (minimum 100mm)');
            }
            
            if (length > 20000) {
                errors.push('Beam length too long (maximum 20000mm)');
            }
        }
        
        if (!elementData.profile) {
            errors.push('Profile is required');
        }
        
        return {
            valid: errors.length === 0,
            errors: errors
        };
    }
}

ComponentRegistry.register('creator', 'beam', BeamCreator);
```

### Advanced Creator - Stairs

```javascript
class StairsCreator extends BaseCreator {
    static meta = {
        type: 'stairs',
        name: 'Steel Stairs',
        icon: 'stairs-icon',
        category: 'structural',
        description: 'Create steel stairs with railings and platforms',
        steps: ['start_point', 'end_point', 'configuration', 'preview']
    };
    
    static getUI() {
        return [
            { 
                id: 'steps', 
                type: 'number', 
                label: 'Number of Steps', 
                value: 12, 
                min: 3, 
                max: 30 
            },
            { 
                id: 'width', 
                type: 'number', 
                label: 'Width (mm)', 
                value: 1000, 
                min: 600, 
                max: 2000 
            },
            { 
                id: 'treadDepth', 
                type: 'number', 
                label: 'Tread Depth (mm)', 
                value: 250, 
                min: 200, 
                max: 400 
            },
            { 
                id: 'riserHeight', 
                type: 'number', 
                label: 'Riser Height (mm)', 
                value: 175, 
                min: 100, 
                max: 220 
            },
            { 
                id: 'includeRailing', 
                type: 'checkbox', 
                label: 'Include Railings', 
                value: true 
            },
            { 
                id: 'includePlatform', 
                type: 'checkbox', 
                label: 'Include Landing Platform', 
                value: false 
            },
            {
                id: 'railingHeight',
                type: 'number',
                label: 'Railing Height (mm)',
                value: 1000,
                min: 800,
                max: 1200,
                dependsOn: 'includeRailing'
            }
        ];
    }
    
    handleStep(stepName, event) {
        const worldPos = this.creationManager.getWorldPosition(event);
        
        switch (stepName) {
            case 'start_point':
                this.stepData.startPoint = worldPos;
                this.completeCurrentStep();
                break;
                
            case 'end_point':
                this.stepData.endPoint = worldPos;
                this.calculateStairsGeometry();
                this.completeCurrentStep();
                break;
                
            case 'configuration':
                // Parameters are set via UI
                this.updateStairsGeometry();
                this.completeCurrentStep();
                break;
                
            case 'preview':
                this.execute();
                break;
        }
    }
    
    calculateStairsGeometry() {
        const start = this.stepData.startPoint;
        const end = this.stepData.endPoint;
        
        const totalRise = end[2] - start[2];
        const totalRun = Math.sqrt(
            Math.pow(end[0] - start[0], 2) + 
            Math.pow(end[1] - start[1], 2)
        );
        
        // Calculate optimal step count
        const optimalSteps = Math.round(totalRise / 175); // 175mm ideal riser
        const actualRiserHeight = totalRise / optimalSteps;
        const actualTreadDepth = totalRun / optimalSteps;
        
        // Update UI parameters with calculated values
        this.setParameterValue('steps', optimalSteps);
        this.setParameterValue('riserHeight', actualRiserHeight);
        this.setParameterValue('treadDepth', actualTreadDepth);
        
        this.stepData.geometry = {
            totalRise,
            totalRun,
            angle: Math.atan2(totalRise, totalRun) * 180 / Math.PI
        };
    }
    
    updateStairsGeometry() {
        // Recalculate based on current parameters
        const steps = this.getParameterValue('steps');
        const riserHeight = this.getParameterValue('riserHeight');
        const treadDepth = this.getParameterValue('treadDepth');
        
        this.stepData.geometry = {
            ...this.stepData.geometry,
            actualSteps: steps,
            actualRiserHeight: riserHeight,
            actualTreadDepth: treadDepth
        };
    }
    
    updatePreview(event) {
        if (this.currentStep < 2) return;
        
        const previewData = {
            type: 'stairs',
            startPoint: this.stepData.startPoint,
            endPoint: this.stepData.endPoint,
            steps: this.getParameterValue('steps'),
            width: this.getParameterValue('width'),
            treadDepth: this.getParameterValue('treadDepth'),
            riserHeight: this.getParameterValue('riserHeight'),
            includeRailing: this.getParameterValue('includeRailing'),
            includePlatform: this.getParameterValue('includePlatform'),
            railingHeight: this.getParameterValue('railingHeight'),
            geometry: this.stepData.geometry
        };
        
        this.preview = this.creationManager.updatePreview(this.preview, previewData);
    }
    
    execute() {
        const elementData = {
            type: 'stairs',
            startPoint: this.stepData.startPoint,
            endPoint: this.stepData.endPoint,
            steps: this.getParameterValue('steps'),
            width: this.getParameterValue('width'),
            treadDepth: this.getParameterValue('treadDepth'),
            riserHeight: this.getParameterValue('riserHeight'),
            includeRailing: this.getParameterValue('includeRailing'),
            includePlatform: this.getParameterValue('includePlatform'),
            railingHeight: this.getParameterValue('railingHeight'),
            geometry: this.stepData.geometry
        };
        
        const validation = this.constructor.validate(elementData);
        if (!validation.valid) {
            EventBus.publish('ui:error', {
                message: 'Invalid stairs parameters',
                errors: validation.errors
            });
            return;
        }
        
        this.creationManager.createElement(elementData);
        
        if (this.shouldRestart()) {
            this.reset();
        }
    }
    
    static validate(elementData) {
        const errors = [];
        
        // Basic validation
        if (!elementData.startPoint || !elementData.endPoint) {
            errors.push('Start and end points are required');
        }
        
        // Stairs-specific validation
        if (elementData.steps < 3) {
            errors.push('Minimum 3 steps required');
        }
        
        if (elementData.riserHeight > 220) {
            errors.push('Riser height exceeds building code maximum (220mm)');
        }
        
        if (elementData.treadDepth < 200) {
            errors.push('Tread depth below building code minimum (200mm)');
        }
        
        // Geometry validation
        if (elementData.geometry) {
            const angle = elementData.geometry.angle;
            if (angle > 45) {
                errors.push('Stairs angle too steep (maximum 45Â°)');
            }
            if (angle < 15) {
                errors.push('Stairs angle too shallow (minimum 15Â°)');
            }
        }
        
        return {
            valid: errors.length === 0,
            errors: errors
        };
    }
}

ComponentRegistry.register('creator', 'stairs', StairsCreator);
```

## Creator Lifecycle Management

### Creation Manager Integration

```javascript
class CreationManager {
    constructor(core) {
        this.core = core;
        this.activeCreator = null;
        this.creatorHistory = [];
    }
    
    startCreation(type) {
        // Stop current creation if active
        if (this.activeCreator) {
            this.stopCreation();
        }
        
        // Get creator class from registry
        const CreatorClass = ComponentRegistry.get('creator', type);
        if (!CreatorClass) {
            throw new Error(`Unknown creator type: ${type}`);
        }
        
        // Create and initialize creator
        this.activeCreator = new CreatorClass(this);
        this.creatorHistory.push({
            type: type,
            startTime: Date.now(),
            creator: this.activeCreator
        });
        
        EventBus.publish('creation:started', {
            type: type,
            creator: this.activeCreator
        });
        
        return this.activeCreator;
    }
    
    stopCreation() {
        if (this.activeCreator) {
            this.activeCreator.destroy();
            
            EventBus.publish('creation:stopped', {
                type: this.activeCreator.constructor.meta.type
            });
            
            this.activeCreator = null;
        }
    }
    
    createElement(elementData) {
        // Validate element data
        const CreatorClass = ComponentRegistry.get('creator', elementData.type);
        if (CreatorClass && typeof CreatorClass.validate === 'function') {
            const validation = CreatorClass.validate(elementData);
            if (!validation.valid) {
                throw new Error(`Invalid element data: ${validation.errors.join(', ')}`);
            }
        }
        
        // Create element through ElementFactory
        const element = ElementFactory.createElement(elementData);
        
        EventBus.publish('element:created', {
            elementId: element.id,
            elementData: element,
            creator: this.activeCreator?.constructor.meta.type
        });
        
        return element;
    }
}
```

## Creator Extension Patterns

### Plugin Creator Example

```javascript
// Plugin creator extending base functionality
class CustomConnectionCreator extends BaseCreator {
    static meta = {
        type: 'custom_connection',
        name: 'Custom Connection',
        icon: 'custom-connection-icon',
        category: 'connections',
        description: 'Create custom bolted connections',
        steps: ['select_primary', 'select_secondary', 'configure'],
        version: '1.0.0',
        author: 'Connection Plugin v1.0'
    };
    
    static getUI() {
        return [
            {
                id: 'connectionType',
                type: 'dropdown',
                label: 'Connection Type',
                options: [
                    { value: 'beam_column', label: 'Beam to Column' },
                    { value: 'beam_beam', label: 'Beam to Beam' },
                    { value: 'column_base', label: 'Column Base Plate' }
                ],
                value: 'beam_column'
            },
            {
                id: 'boltSize',
                type: 'dropdown',
                label: 'Bolt Size',
                options: ['M12', 'M16', 'M20', 'M24'],
                value: 'M16'
            },
            {
                id: 'boltGrade',
                type: 'dropdown',
                label: 'Bolt Grade',
                options: ['8.8', '10.9'],
                value: '8.8'
            }
        ];
    }
    
    handleStep(stepName, event) {
        switch (stepName) {
            case 'select_primary':
                this.selectElement('primary', event);
                break;
            case 'select_secondary':
                this.selectElement('secondary', event);
                break;
            case 'configure':
                this.execute();
                break;
        }
    }
    
    selectElement(role, event) {
        const intersected = this.creationManager.getIntersectedElement(event);
        if (intersected) {
            this.stepData[role + 'Element'] = intersected;
            this.completeCurrentStep();
        }
    }
    
    execute() {
        const connectionData = {
            type: 'custom_connection',
            primaryElement: this.stepData.primaryElement.id,
            secondaryElement: this.stepData.secondaryElement.id,
            connectionType: this.getParameterValue('connectionType'),
            boltSize: this.getParameterValue('boltSize'),
            boltGrade: this.getParameterValue('boltGrade')
        };
        
        this.creationManager.createElement(connectionData);
        
        if (this.shouldRestart()) {
            this.reset();
        }
    }
}

// Register plugin creator
ComponentRegistry.register('creator', 'custom_connection', CustomConnectionCreator);
```

The Creator Pattern provides a robust, extensible foundation for TomCAD's element creation system, enabling consistent user experience while allowing for complex, type-specific creation workflows.